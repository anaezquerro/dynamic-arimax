---
title: "Documentación sobre autoajuste de modelos ARIMAX"
author: "Ana Xiangning Pereira Ezquerro"
date:  "Versión `r format(Sys.time(), '%d %B, %Y')`"
output:
  pdf_document:
    number_sections: yes
    latex_engine: lualatex
    fig_caption: yes
    toc: yes
    highlight: tango
    df_print: kable
    citation_package: biblatex
  html_document:
    toc: true
    toc_float: true
    df_print: paged
    number_sections: true
    theme: hpstr
    highlight: tango
  prettydoc::html_pretty:
    toc: true
    df_print: paged
    number_sections: true
    theme: hpstr
    highlight: github
fontsize: 12pt
geometry: margin=0.7in
classoption: a4paper
documentclass: article
header-includes:
- \usepackage{sfmath}
- \renewcommand*\familydefault{\sfdefault}
- \renewcommand{\baselinestretch}{1.2}
- \setlength{\parskip}{1em}
- \usepackage{xcolor}
- \input{confi.tex}
always_allow_html: yes
bibliography: references.bib
biblio-style: bwl-FU
linkcitations: true
linkcolor: blue
lang: es
---

```{r, echo=F, warning=F, message=F}
knitr::opts_chunk$set(fig.align='center', fig.width = 10, 
                      fig.height = 8, message=F, comment='')
eval(parse("plot_tools.R", encoding="UTF-8"))
eval(parse("arima_simulation.R", encoding="UTF-8"))
eval(parse("auto_fit_arima.R", encoding="UTF-8"))
eval(parse("automatic_selection.R", encoding="UTF-8"))
eval(parse("forecasting.R", encoding="UTF-8"))

# Librerías de series temporales
library(fpp2)
library(tseries)
library(TSA)
library(seastests)
library(forecast)

# Librerías para los gráficos
library(plotly)
library(forecast)

# Auxiliares
library(prettydoc)
library(stringi)
library(stringr)
library(polynom)
library(parallel)

# Función para mostrar y guardar las gráficas de plotly
display <- function(fig, name, width=800, height=400) {
  
  if (is.null(knitr::opts_knit$get("rmarkdown.pandoc.to"))) {
    return(fig)
  }
  if (knitr::opts_knit$get("rmarkdown.pandoc.to") == "latex") {
    figpath <- paste0('figures/', name, ".pdf")
    save_image(fig, figpath, width=width, height=height)
    return(knitr::include_graphics(figpath))
  }
  if (knitr::opts_knit$get("rmarkdown.pandoc.to") == "html") {
    return(fig)
  }
}

dir.create("figures", showWarnings=F)
```

\newpage

# Función de auto-ajuste de modelos ARIMAX (`auto.fit.arima` en `auto_fit_arima.R`)

**Descripción**: Obtiene el ajuste de un modelo válido para una serie temporal y, opcionalmente, una o varias variables regresoras. En el ajuste obtenido todos los parámetros son estadísticamente significativos y se verifica que se cumplen las hipótesis de independencia y media nula sobre sus residuos. Este ajuste es escogido por un criterio de información que se introduce como argumento.

**Devuelve**:

a.  Ajuste para la serie temporal (objeto `Arima`) si existe y se puede optimizar.
b.  `NA` en caso de que no exista o no se pueda optimizar.
c.  Si `plot_result = TRUE` y se ha conseguido ajustar un modelo válido para la serie, devuelve un objeto de tipo `list` donde se encuentra el ajuste (`$ajuste`), el gráfico de la serie (`$fig_serie`) y el gráfico de los residuos del ajuste (`$fig_residuals`).

```{r, eval=F}
auto.fit.arima(serie, xregs = NULL, seasonal = TRUE, ic = c("aicc", "aic", "bic"),
               d = NA, D = NA, alpha = 0.05, show_info = TRUE, plot_result = FALSE)
```

**Argumentos**:

-   `serie` [`ts`]: Serie temporal sobre la que se quiere obtener un ajuste válido de un modelo ARIMAX.
-   `xregs` [`ts`]: Se pueden introducir series de tiempo que actuarán como variables regresoras sobre `serie`. Por defecto, `xregs=NULL`, i.e. no hay variables regresoras.
-   `ic` [`character`]: Criterio de información para escoger modelos.
    -   `"aicc"`: Criterio de Información de Akaike Corregido (por defecto).
    -   `"aic"`: Criterio de Información de Akaike.
    -   `"bic"`: Criterio de Información Bayesiano.
-   `d` [`numeric`]: Orden de diferenciación regular de `serie` sobre el que se limita la búsqueda de modelos. Si no se introduce ningún valor el valor máximo de la búsqueda es `d=4`.
-   `D` [`numeric`]: Orden de de diferenciación estacional de `serie` sobre el que se limita la búsqueda de modelos. Si no se introduce ningún valor el valor máximo de la úsqueda es `D=3`.
-   `alpha` [`numeric`]: Valor entre 0 y 1 que indica el nivel de significación de los tests para chequear:
    -   La significación de los parámetros de los ajustes.
    -   La validez del modelo a partir del test de independencia de residuos y el test de media nula de los residuos.
-   `show_info` [`boolean`]: Indica si se muestra la información de la búsqueda del mejor ajuste o no. Por defecto `TRUE`.
-   `plot_results` [`boolean`]: Indica si se deben devolver los gráficos de la serie temporal y los residuos del modelo obtenido. Por defecto `FALSE`.

**Consideraciones**:

-   Para chequear la independencia de residuos se utiliza el contraste de Ljung-Box (`Box.test`). El número de retardos se escoge en base a la estacionalidad de la serie (si la hay) y la longitud de la misma (función `ljungbox_lag`).
-   Para chequear la media nula de los residuos se utiliza el `t.test`.
-   Para chequear la normalidad de los residuos se utilizar el test de Jarque-Bera (`jarque.bera.test`) y el de Shapiro-Wilks (`shapiro.test`).
-   Los modelos considerados tendrán siempre un orden de diferenciación regular igual o inferior a 3 ($d\leq 3$) y un orden de diferenciación estacional menor o igual a 2 ($D\leq 2$).

**Ejemplo de uso**: Evolución de la gripe en Cataluña.

```{r}
dat <- read.csv("data/evolucion_gripe_covid.csv")
gripe <- ts(dat$sdgripal, start=c(2020, 40), frequency=52)
result_gripe <- auto.fit.arima(gripe, plot_result = TRUE)
display(result_gripe$fig_serie, "serie gripe", width=1000, height=800)
display(result_gripe$fig_residuals, "residuals gripe", width=1000, height=800)
```

**Ejemplo de uso**: [Nivel mensual de dióxido de carbono (Co2) medido en el Observatorio de Mauna Loa (Hawaii)](ftp://ftp.cmdl.noaa.gov/ccg/co2/trends/co2_mm_mlo.txt). La serie comienza en Marzo de 1958.

```{r}
co2 <- ts(scan('data/co2MaunaLoa.dat'), start=c(1958, 3), frequency=12)
result_co2 <- auto.fit.arima(co2, ic="aicc", plot_result=TRUE)
display(result_co2$fig_serie, "serie co2", width=1000, height=800)
display(result_co2$fig_residuals, "residuals co2", width=1000, height=800)
```

\newpage

# Función de selección automática de múltiples variables y retardos en modelos ARIMAX (`auto.fit.arima.regression` en `automatic_selection.R`)

**Descripción**: Método de selección las variables regresoras y sus respectivos retardos (óptimos) para una serie de tiempo en base al método propuesto por @cryer2008time.

**Devuelve**:

a.  Un objeto de tipo `list` donde se almacena el ajuste de un modelo válido de todas las variables regresoras (`$ajuste`, objeto `Arima`) que se han seleccionado para modelar la variable respuesta y el número de diferenciaciones regulares que se han aplicado sobre los datos para que los errores del ajuste sean estacionarios (`$ndiff`).
b.  `NA` en caso de que no se haya podido ajustar ningún modelo (incluso uno sin variables regresoras).

```{r, eval=F}
auto.fit.arima.regression(serie, xregs, ic = c("aicc", "aic", "bic"), 
                         alpha = 0.05, stationary_method='auto.arima', 
                         show_info = TRUE, ndiff=0)
```

**Argumentos**:

-   `serie` [`ts`]: Serie temporal que funciona como variable respuesta en el modelo de regresión dinámico sobre el que se realiza la selección de variables regresoras.
-   `xregs` [`data.frame`]: Dataframe con las series temporales que actuarán como variables regresoras de `serie`. Es importante que los nombres de las columnas tengan un significado de cara a identificar las variables regresoras.
-   `alpha` [`numeric`]: Valor entre 0 y 1 que indica el nivel de significación de los tests para chequear:
    -   La significación de los parámetros de los ajustes.
    -   La validez del modelo a partir del test de independencia de residuos y el test de media nula de residuos.
    -   La selección de retardos óptimos.
    -   La comprobación de tendencia de las series.
-   `stationary_method` [`character`]: Método utilizado para chequear la estacionariedad de una serie temporal en las fases de preblanqueado (técnica usada para eliminar la correlación espuria entre dos series). Si `stationary_method = 'auto.arima'`, se utiliza la función `forecast::auto.arima` para ajustar un modelo ARIMA(p,d,q) y chequear si $d > 0$ (si se cumple esta condición se asume que la serie no es estacionaria). Si `stationary_method = 'adf.test'` se usa el test Dickey-Fuller (`tseries::adf.test`) para chequear la estacionariedad de una serie temporal.
-   `show_info` [`boolean`]: Indica si se muestra la información de la selección de variables o no.
-   `ndiff` [`numeric`]: Parámetro interno del programa (no utilizar) para diferenciar todas las variables cuando no se pueda ajustar un modelo válido con errores estacionarios y mantener un registro del número de diferenciaciones que se están realizando. Nótese que cuando, en la salida de la función, el valor de `$ndiff` es mayor a 0, se han aplicado `ndiff` diferencias a los datos (tanto a la variable respuesta como a las regresoras) y por tanto el modelo que se devuelve en `$ajuste` se trata de un modelo de diferencias, no sobre los datos originales.

*Nota*: No se mostrará la información del ajuste de cada modelo para cada variable regresora.

**Ejemplo de uso**: Logaritmo de las ventas semanales y el precio de patatas fritas *Bluebird* de NUeva Zelanda. El período de observación es de 104 semanas (desde el 20 de Septiembre de 1988 hasta el 10 de Septiembre de 2000).

```{r}
load("data/patatas.dat")
Y <- patatas[,1]   
X <- patatas[,2]
ajuste_patatas <- auto.fit.arima.regression(Y, data.frame(X=X))
```

**Ejemplo de uso**: Serie temporal sobre el *stock* de Microsoft.

```{r}
microsoft <- read.csv('data/microsoft-stock.csv')
close_price <- ts(microsoft$Close)   # variable respuesta
regresoras <- as.data.frame(
    lapply(microsoft[, c('Open', 'High', 'Low', 'Volume')], ts))

elapsed_time <- system.time(
    ajuste <- auto.fit.arima.regression(close_price, regresoras)
)
```

```{r}
print(elapsed_time)  # tiempo secuencial
```


```{r}
eval(parse("parallel.R", encoding="UTF-8"))
elapsed_time <- system.time(
    ajuste <- auto.fit.arima.regression(close_price, regresoras, show_info=F)
)
print(elapsed_time)
```


**Ejemplo de uso**: Modelización de la serie de tiempo de muertes en España debido al COVID19, considerando como posibles variables regresoras:

-   Los casos confirmados y curados en España.
-   Los casos confirmados y muertes en Francia.
-   Los casos confirmados y muertes en Inglaterra.

```{r}
confirmed <- read.csv("data/covid-global-confirmed-bycountry.csv")
deaths <- read.csv("data/covid-global-deaths-bycountry.csv")
recovered <- read.csv("data/covid-global-recovered-bycountry.csv")

confirmed_spain <- ts(confirmed$Spain, frequency=7)
deaths_spain <- ts(deaths$Spain, frequency=7)
recovered_spain <- ts(recovered$Spain, frequency=7)

confirmed_france <- ts(confirmed$France, frequency=7)
confirmed_england <- ts(confirmed$United.Kingdom, frequency=7)

deaths_france <- ts(deaths$France, frequency=7)
deaths_england <- ts(deaths$United.Kingdom, frequency=7)

regresoras <- data.frame(confirmed_spain, recovered_spain)

elapsed_time <- system.time(
    ajuste <- auto.fit.arima.regression(deaths_spain, regresoras)
)
```




\newpage

# Funciones auxiliares

## Ajuste de los coeficientes de un modelo (`fit.coefficients()` de `auto_fit_arima.R`)

**Descripción**: Elimina de forma incremental los coeficientes no significativos en un modelo.

**Devuelve**: Ajuste de un modelo donde todos sus coeficientes son significativamente distintos de cero.

```{r, eval=F}
fit.coefficients(ajuste, alpha=0.05, show_info=T)
```

**Argumentos**:

-   `ajuste` [`Arima`]: Ajuste de un modelo ARIMA sobre el que se deben eliminar los coeficientes no significativos.
-   `alpha` [`numeric`]: Valor entre 0 y 1 que especifica el nivel de significación para retirar parámetros del modelo. Por defecto es 5%.
-   `show_info` [`boolean`]: Indica si se debe mostrar información sobre los parámetros que se van retirando del ajuste o no. Por defecto, va mostrando esta información en consola.

## Ajuste de un ARIMA vía múltiples optimizadores (`fit.model()` de `auto_fit_arima.R`)

**Descripción**: Ajuste de un modelo ARIMA dados sus órdenes sobre una serie temporal, manejando posibles errores de optimización y probando con otros métodos en caso de que el que viene dado por defecto provoque errores. Los optimizadores con los que prueba son, en este orden: `BFGS`, `Nelder-Mead`, `CG`, `L-BFGS-B`, `SANN` y `Brent`.

**Devuelve**: Modelo ARIMA para los parámetros y serie temporal dada o `NA` en caso de que no haya sido posible ajustar ningún modelo por problemas de optimización.

```{r, eval=F}
fit.model(serie, orders, xregs=NULL, fixed=NULL)
```

**Argumentos**:

-   `serie` [`Arima`]: Serie temporal sobre la que se ajusta el modelo ARIMA.
-   `orders` [`list`]: Objeto de tipo lista donde se especifica información sobre los órdenes regulares y estacionales del modelo. El formato es el siguiente:
    -   `orders$regular = c(p, d, q)` [`numeric`]: Especifica los órdenes regulares.
    -   `orders$seasonal = c(P, D, Q)` [`numeric`]: Especifica los órdenes estacionales.
    -   `orders$include_constant` [`boolean`]: Especifica si se debe incluir la media en un ajuste sin diferencias.
-   `xregs` [`ts`]: Matriz de posibles variables regresoras.
-   `fixed`: Vector de valores fijos para los coeficientes del modelo ARIMA que se quiere ajustar.

## Selección del retardo óptimo (`select.optimal.lag()` de `automatic_selection.R`)

**Descripción**: Selección del retardo significativo y óptimo de dos series (asumiendo que una funciona como variable explicativa y otra como variable respuesta en un modelo de regresión con componente temporal). Esta selección se realiza siguiendo el procedimiento descrito por @cryer2008time usando las funciones `tseries::adf.test()` o `auto.arima` para chequear estacionariedad, `seastests::isSeasonal` para chequear presencia de estacionalidad y `TSA::prewhiten()` para aplicar el preblanqueado sobre las dos series.

**Devuelve**: El retardo óptimo de las dos series o `NA` en caso de que ningún retardo sea significativo.

```{r, eval=F}
select.optimal.lag(serie, xreg, alpha=0.05, max_lag=NA)
```

**Argumentos**:

-   `serie` [`ts`]: Serie temporal que funciona como variable respuesta.
-   `xreg` [`ts`]: Variable regresora de `serie`.
-   `alpha` [`numeric`]: Valor entre 0 y 1 que indica el nivel de significación para aceptar o no la hipótesis nulas en los contrastes de signficación, estacionariedad y estacionalidad.
-   `max_lag` [`numeric` o `NA`]: Opcionalmente, se puede añadir un valor que limite el valor del retardo óptimo tal que su valor absoluto siempre sea menor que `max_lag`.
-   `method` [`character`]: Selecciona el método para chequear estacionairedad sobre ambas series. Cuando se fija como `adf.test` se usa el test Dickey-Fuller y cunado se fija como `auto.arima` se ajusta un modelo ARIMA(p,d,q) con la función `forecast::auto.arima()` y se comprueba si $d>0$.

\newpage

# Predicciones puntuales a horizonte $h$ e intervalos de confianza (`forecasting_model()` de `forecasting.R`)

**Descripción**: A partir del ajuste de un ARIMAX realiza predicciones puntuales a horizonte $h$ de cada variable regresora para introducirlas en las predicciones puntuales de la variable respuesta.

**Devuelve**: Objeto `forecast` con las predcciones puntuales y los intervalos de confianza.

```{r, eval=F}
forecast_model(ajuste, h, mode=c('bootstrap', 'norm'), levels=c(80, 90))
```

**Argumentos**:

-   `ajuste` [`Arima`]: Ajuste de un modelo de regresión con series temporales sobre el que se quieren hacer predicciones puntuales e intervalos de confianza.
-   `h` [`numeric`]: Valor horizonte de las predicciones.
-   `mode` [`character`]: Modo de realizar las predicciones: basadas en normalidad sobre los residuos (`norm`) o a través de *bootstrap* (`bootstrap`).
-   `levels` [`vector`]: Vector numérico de los niveles a los que se quieren hacer los intervalos de predicción.

**Ejemplo de uso**:

```{r}
load("data/patatas.dat")
Y <- ts(patatas[,1])
X <- ts(patatas[,2])
ajuste_patatas <- auto.fit.arima.regression(Y, data.frame(X=X))
ajuste_patatas$xreg <- cbind(X=ts(ajuste_patatas$xreg))

# Calculamos las predicciones puntuales
preds <- forecast_model(ajuste_patatas, h=10, mode='bootstrap')
display(plot_forecast(preds), name='preds_patatas')
```

\newpage

# Comprobación con ejemplos

## Evolución de la gripe en Cataluña

```{r}
# Carga de datos
cataluna <- read.csv("data/evolucion_gripe_covid.csv")
str(cataluna)
```

El dataset `evolucion_gripe_covid.csv` contiene información sobre la evolución de la gripe y el COVID19 en las distintas áreas sanitarias de Cataluña y en toda la comunidad a lo largo del tiempo. Cada dato recogido representa el número de casos confirmados (de gripe y COVID19) en una semana (desde la 40ª semana de 2020 hasta la 46ª semana de 2021).

Vamos a intentar modelizar la evolución de la gripe con un ARIMA a través de los siguientes métodos:

-   Usando la función `auto.arima` y ajustando los coeficientes para obtener un ajuste válido.
-   Usando la función `auto.fit.arima` que realiza todo el proceso.

```{r}
# Los datos ya están ordenados temporalmente 
gripe <- ts(cataluna$sdgripal, start=c(2020, 40), frequency=52)
```

Analizamos el gráfico secuencial y la fas y fap muestral:

```{r}
display(result_gripe$fig_serie, "serie gripe", width=1000, height=800)
```

A continuación, usamos la función `auto.arima`:

```{r}
ajuste <- auto.arima(gripe, stepwise=FALSE, approximation=FALSE, trace=TRUE)
```

Y comprobamos que el mejor modelo (siguiendo el AICc) es un ARIMA(2, 0, 1) con media.

```{r}
ajuste
```

A continuación, comprobamos qué parámetros *no* son signficativos:

```{r}
alpha <- 0.05; stat <- qnorm(1-0.05/2)
abs(ajuste$coef) < stat*sqrt(diag(ajuste$var.coef))
```

En este caso, **todos** los parámetros son significativos y por tanto se trata de un ajuste válido. Finalmente, realizamos el análisis de residuos para chequear las hipótesis de independencia y media nula.

```{r}
checkresiduals(ajuste)
t.test(ajuste$residuals, mu=0)
```

El test de independencia de Ljung-Box y el test de media nula nos dicen que los residuos sí son independientes y tienen media cero, por tanto se puede considerar que el ajuste es válido para modelizar la evolución de la gripe.

El objetivo de la función `auto.fit.arima` es realizar todo este proceso de forma automática. El resultado que nos devuelva debe ser el mismo que el que hemos obtenido haciendo los cálculos paso a paso:

```{r}
ajuste <- auto.fit.arima(gripe)
```

Adicionalmente, la función `auto.fit.arima` nos avisa de que los residuos no siguen una distribución normal, por tanto tendremos que tener cuidado al hacer predicciones sobre la serie.




## Selección de covariables para predecir el precio de cierre en el *stock* de Microsoft

Cargamos la base de datos y separamos la variable respuesta (`response`) del conjunto de variables regresoras (`Open`, `High`, `Low`, `Volume`).

```{r}
microsoft <- read.csv('data/microsoft-stock.csv')
str(microsoft)
response <- ts(microsoft$Close)
open <- ts(microsoft$Open)
high <- ts(microsoft$High)
low <- ts(microsoft$Low)
volume <- ts(microsoft$Volume)
```

**Fase 1**: Preblanqueado para cada par $(X_i, Y)$ para eliminar la correlación espuria y para obtener el retardo significativo óptimo. Realizamos este procedimiento con la variable regresora `Open`:

```{r}
open_lagged <- open; close_lagged <- close

# Chequear estacionariedad con el adf.test y diferenciar hasta eliminar la 
# estacionariedad en ambas
adf.test(open_lagged); adf.test(close_lagged)
open_lagged <- diff(open_lagged); close_lagged <- diff(close_lagged)

# Aplicando una única diferenciación ya se obtienen dos variables sin estacionariedad
adf.test(open_lagged); adf.test(close_lagged)

# Realizamos el preblanqueado 
series_prewhiten <- TSA::prewhiten(open_lagged, close_lagged, plot=F)

corr_plot <- plot_correlations(
    lags=c(series_prewhiten$ccf$lag), values=c(series_prewhiten$ccf$acf),
    n=series_prewhiten$ccf$n.used, title='Gráfico de correlaciones simple'
)
display(corr_plot, "fig-open1", width=1000, height=800)
```

Como podemos apreciar, el retardo óptimo (no superior a $0$) se encuentra en $r=0$. A continuación, procedemos a ajustar un modelo ARIMA (sin la restricción de estacionariedad sobre sus residuos). Podemos ajustar este modelo a mano (utilizando la función `stats::auto.arima` y retirando los coeficientes no significativos), pero para este caso utilizaremos la función ya descrita anteriormente, `auto.fit.arima`, que realiza todo este proceso de forma automática.

```{r}
ajuste_open <- auto.fit.arima(close, xregs=cbind(open=open), show_info=F)
ajuste_open
```

Repetimos el poceso de preblanqueado y ajuste del modelo (retardando la variable regresora con el retardo $r$ óptimo) para todas las variables restantes:

```{r}
# Preblanqueado con la variable high
high_lagged <- high; close_lagged <- close
adf.test(high_lagged); adf.test(close_lagged)
high_lagged <- diff(high_lagged); close_lagged <- diff(close_lagged)
adf.test(high_lagged); adf.test(close_lagged)

series_prewhiten <- TSA::prewhiten(high_lagged, close_lagged, plot=F)
corr_plot <- plot_correlations(
    lags=c(series_prewhiten$ccf$lag), values=c(series_prewhiten$ccf$acf),
    n=series_prewhiten$ccf$n.used, title='Gráfico de correlaciones simple'
)
display(corr_plot, "fig-high1", width=1000, height=800)

# Preblanqueado con la variable low
low_lagged <- low; close_lagged <- close
adf.test(low_lagged); adf.test(close_lagged)
low_lagged <- diff(low_lagged); close_lagged <- diff(close_lagged)
adf.test(low_lagged); adf.test(close_lagged)

series_prewhiten <- TSA::prewhiten(low_lagged, close_lagged, plot=F)
corr_plot <- plot_correlations(
    lags=c(series_prewhiten$ccf$lag), values=c(series_prewhiten$ccf$acf),
    n=series_prewhiten$ccf$n.used, title='Gráfico de correlaciones simple'
)
display(corr_plot, "fig-low1", width=1000, height=800)

# Preblanqueado con la variable volume
volume_lagged <- volume; close_lagged <- close
adf.test(volume_lagged); adf.test(close_lagged)
volume_lagged <- diff(volume_lagged); close_lagged <- diff(close_lagged)
adf.test(volume_lagged); adf.test(close_lagged)

series_prewhiten <- TSA::prewhiten(volume_lagged, close_lagged, plot=F)
corr_plot <- plot_correlations(
    lags=c(series_prewhiten$ccf$lag), values=c(series_prewhiten$ccf$acf),
    n=series_prewhiten$ccf$n.used, title='Gráfico de correlaciones simple'
)
display(corr_plot, "fig-volume1", width=1000, height=800)
```

Los resultados del preblanqueado sobre todas las variables es que los retardos óptimos (para todas las variables) se encuentran en $r=0$, por lo que no es necesario diferenciar ninguna variable regresora. A continuación, ajustamos los modelos ARIMAX entre cada par $(X_i, Y)$:

```{r}
# Ajuste de un modelo con la variable high
ajuste_high <- select.optimal.lag(ts(close[2:length(close)]),
                              ts(volume[2:length(open)]))
ajuste_high

# Ajuste de un modelo con la variable low
ajuste_low <- auto.fit.arima(close, xregs=cbind(low=low), show_info=F)
ajuste_low

# Ajuste de un modelo con la variable volume
ajuste_volume <- auto.fit.arima(close, xregs=cbind(volume=volume), show_info=F)
ajuste_volume
```

Los resultados obtenidos en esta primera iteración son los siguientes:

- El mejor modelo para la variable `Open` es un ARIMA(0,0,0) con AICc=5927.5 y retardo nulo.
- El mejor modelo para la variable `High` es un ARIMA(1,0,3) con AICc=4930.62 y retardo nulo.
- No se puede encontrar un modelo para la variable `Low` con retardo nulo.
- No se puede encontrar un modelo para la variable `Volume` con retardo nulo.

Como el "mejor" criterio de información se obtiene al añadir la variable `High` al modelo, se toma dicho ajuste y se calculan los residuos. Estos residuos pasarán a ser la variable respuesta y se repetirá el proceso en busca de nuevas variables a añadir al modelo.

```{r}
response <- residuals(ajuste_high, type='regression')
```

**Fase 2**: Búsqueda de variables a añadir al modelo tomando como variable respuesta los residuos del modelo anterior.

Aplicamos preblanqueado a las variables que no se han introducido en el modelo (i.e. todas excepto `High`):

```{r}
# Preblanqueado con la variable open
open_lagged <- open; response_lagged <- response
adf.test(open_lagged); adf.test(response_lagged)
open_lagged <- diff(open_lagged); response_lagged <- diff(response_lagged)
adf.test(open_lagged); adf.test(response_lagged)

series_prewhiten <- TSA::prewhiten(open_lagged, response_lagged, plot=F)
corr_plot <- plot_correlations(
    lags=c(series_prewhiten$ccf$lag), values=c(series_prewhiten$ccf$acf),
    n=series_prewhiten$ccf$n.used, title='Gráfico de correlaciones simple'
)
display(corr_plot, "fig-open2", width=1000, height=800)

# Preblanqueado con la variable low
low_lagged <- low; response_lagged <- response
adf.test(low_lagged); adf.test(response_lagged)
low_lagged <- diff(low_lagged); response_lagged <- diff(response_lagged)
adf.test(low_lagged); adf.test(response_lagged)

series_prewhiten <- TSA::prewhiten(low_lagged, response_lagged, plot=F)
corr_plot <- plot_correlations(
    lags=c(series_prewhiten$ccf$lag), values=c(series_prewhiten$ccf$acf),
    n=series_prewhiten$ccf$n.used, title='Gráfico de correlaciones simple'
)
display(corr_plot, "fig-low2", width=1000, height=800)

# Preblanqueado con la variable volume
volume_lagged <- volume; response_lagged <- response
adf.test(volume_lagged); adf.test(response_lagged)

series_prewhiten <- TSA::prewhiten(volume_lagged, response_lagged, plot=F)
corr_plot <- plot_correlations(
    lags=c(series_prewhiten$ccf$lag), values=c(series_prewhiten$ccf$acf),
    n=series_prewhiten$ccf$n.used, title='Gráfico de correlaciones simple'
)
display(corr_plot, "fig-volume2", width=1000, height=800)
```


En esta segunda iteración 
